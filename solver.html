<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeNav: AI Solver - Mission Aerospace</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <!-- Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Orbitron', sans-serif;
            background: radial-gradient(ellipse at center, #0a0a2a 0%, #1a1a3a 50%, #0a0a2a 100%);
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Space Background */
        #space-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: 
                radial-gradient(2px 2px at 20px 30px, #ffffff, transparent),
                radial-gradient(2px 2px at 40px 70px, #00d4ff, transparent),
                radial-gradient(1px 1px at 90px 40px, #ffffff, transparent),
                radial-gradient(1px 1px at 130px 80px, #00d4ff, transparent),
                radial-gradient(2px 2px at 160px 30px, #ffffff, transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: gradientShift 20s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 0%; }
            50% { background-position: 100% 100%; }
        }

        /* Header */
        .solver-header {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 255, 255, 0.05));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.1);
        }

        .solver-title {
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #00d4ff, #ffffff, #00d4ff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease-in-out infinite;
            margin-bottom: 10px;
        }

        .solver-subtitle {
            font-size: 1.2rem;
            color: #00d4ff;
            opacity: 0.8;
        }

        /* Main Container */
        .solver-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Cube Container */
        #cube-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 20px;
            padding: 20px;
            height: 500px;
            position: relative;
            overflow: hidden;
        }
        
                #cube-container canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
            border-radius: 15px;
        }

        #cube-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.1), transparent);
            animation: shimmer 4s infinite;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        #cube-container canvas {
            width: 100% !important;
            height: 100% !important;
            cursor: grab;
            touch-action: none;
            pointer-events: auto;
            user-select: none;
            position: relative;
            z-index: 10;
        }

        /* Algorithm Panel */
        .algorithm-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 20px;
            padding: 20px;
            height: 500px;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.1);
        }

        .algorithm-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #00d4ff;
            margin-bottom: 20px;
            text-align: center;
        }

        .step-item {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .step-item.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
            transform: scale(1.02);
        }

        .step-item.completed {
            background: rgba(0, 255, 0, 0.1);
            border-color: #00ff00;
            opacity: 0.7;
        }

        .step-number {
            font-weight: 700;
            color: #00d4ff;
            font-size: 1.1rem;
        }

        .step-description {
            color: #ffffff;
            margin: 5px 0;
        }

        .step-moves {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
            color: #00d4ff;
            font-size: 0.9rem;
        }

        .current-move {
            background: rgba(255, 255, 0, 0.2);
            border-color: #ffff00;
            color: #ffff00;
        }

        /* Control Panel */
        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 20px;
            padding: 20px;
            margin-top: 20px;
            grid-column: 1 / -1;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.1);
        }

        .btn-solver {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .btn-solver:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
            background: linear-gradient(135deg, #0099cc, #00d4ff);
        }

        .btn-solver:disabled {
            opacity: 0.5;
            transform: none;
            cursor: not-allowed;
        }

        .progress-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin: 10px 0;
        }

        .progress-bar {
            background: linear-gradient(90deg, #00d4ff, #0099cc);
            height: 8px;
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .status-text {
            color: #00d4ff;
            font-weight: 600;
            text-align: center;
            margin: 10px 0;
        }

        /* Back Button */
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            z-index: 1000;
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
            color: white;
            text-decoration: none;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .solver-container {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 15px;
            }
            
            .solver-title {
                font-size: 2rem;
            }
            
            #cube-container, .algorithm-panel {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <!-- Space Background -->
    <div id="space-bg"></div>
    
    <!-- Back Button -->
    <a href="index.html" class="back-btn">‚Üê Back to Cube</a>
    
    <!-- Header -->
    <div class="solver-header">
        <h1 class="solver-title">üß† AI Solver</h1>
        <p class="solver-subtitle">Layer-by-Layer (LBL) Method - Real-time Visualization</p>
    </div>
    
    <!-- Main Container -->
    <div class="solver-container">
        <!-- Cube Container -->
        <div id="cube-container">
            <!-- Three.js canvas will be inserted here -->
        </div>
        
        <!-- Algorithm Panel -->
        <div class="algorithm-panel">
            <h3 class="algorithm-title">Solving Steps</h3>
            <div id="steps-container">
                <!-- Steps will be dynamically generated -->
            </div>
        </div>
    </div>
    
    <!-- Control Panel -->
    <div class="control-panel">
        <div class="row">
            <div class="col-md-6">
                <button class="btn-solver" onclick="solveFixedScrambleLBL()">üß† Complete LBL Solve</button>
                <button class="btn-solver" onclick="solveWithLBL()">üß† LBL Method Solve</button>
                <button class="btn-solver" onclick="pauseSolver()">‚è∏Ô∏è Pause</button>
                <button class="btn-solver" onclick="resetSolver()">üîÑ Reset</button>
                <button class="btn-solver" id="scrambleBtn" onclick="scrambleFixedLBL()">üé≤ Scramble (Fixed)</button>
            </div>
            <div class="col-md-6">
                <div class="progress-container">
                    <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
                </div>
                <div class="status-text" id="status-text">Ready - Click "Scramble (Fixed)" then "Complete LBL Solve"</div>
            </div>
        </div>
    </div>

    <!-- Solver Script -->
    <script>
        // Global variables for cube functionality
        let scene, camera, renderer, controls, cubeGroup;
        let isSolving = false;
        let isPaused = false;
        let currentStep = 0;
        let currentMove = 0;
        let solverSteps = [];
        let moveHistory = [];
        let moveCount = 0;
        let autoSolveMode = false; // Add this to match main page
        
        // EPS to handle float precision - EXACT same as main page
        const EPS = 0.01;
        
        // Rotation mapping for each face - EXACT same as main page
        const rotationMap = {
            U: { axis: 'y', value: 0.6, dir: -1 },
            D: { axis: 'y', value: -0.6, dir: 1 },
            L: { axis: 'x', value: -0.6, dir: -1 },
            R: { axis: 'x', value: 0.6, dir: 1 },
            F: { axis: 'z', value: 0.6, dir: -1 },
            B: { axis: 'z', value: -0.6, dir: 1 },
        };
        

        
        // Internal Cube State Representation
        const faceOrder = ['U', 'D', 'F', 'B', 'R', 'L'];
        
        // Each corner cubie: [color1, color2, color3] in standard orientation
        let cubeState = [
            ['W', 'G', 'O'], // 0: UFL (Up-Front-Left)
            ['W', 'R', 'G'], // 1: UFR (Up-Front-Right)
            ['W', 'B', 'R'], // 2: URB (Up-Right-Back)
            ['W', 'O', 'B'], // 3: UBL (Up-Back-Left)
            ['Y', 'O', 'G'], // 4: DFL (Down-Front-Left)
            ['Y', 'G', 'R'], // 5: DFR (Down-Front-Right)
            ['Y', 'R', 'B'], // 6: DRB (Down-Right-Back)
            ['Y', 'B', 'O']  // 7: DBL (Down-Back-Left)
        ];
        
        // Corner positions mapping
        const cornerPositions = [
            [-0.6, 0.6, -0.6],  // 0: UFL
            [0.6, 0.6, -0.6],   // 1: UFR
            [0.6, 0.6, 0.6],    // 2: URB
            [-0.6, 0.6, 0.6],   // 3: UBL
            [-0.6, -0.6, -0.6], // 4: DFL
            [0.6, -0.6, -0.6],  // 5: DFR
            [0.6, -0.6, 0.6],   // 6: DRB
            [-0.6, -0.6, 0.6]   // 7: DBL
        ];
        
        // Color mapping
        const colorMap = {
            'W': 'WHITE', 'Y': 'YELLOW', 'G': 'GREEN', 
            'B': 'BLUE', 'R': 'RED', 'O': 'ORANGE'
        };
        
        // Dynamic 2x2 Cube Solver - Layer by Layer (LBL) Method
        class CubeSolver {
            constructor() {
                this.internalState = [...cubeState]; // Copy the initial state
                this.visualState = this.getCubeState();
                console.log('üîç CubeSolver initialized with internal state:', this.internalState);
                console.log('üîç CubeSolver initialized with visual state:', this.visualState);
            }
            
            // Validate cube state before solving
            validateCubeState() {
                const colorCount = {};
                for (const corner of this.internalState) {
                    if (new Set(corner).size !== 3) {
                        console.error('‚ùå Invalid corner found:', corner);
                        return false; // invalid corner
                    }
                    for (const color of corner) {
                        colorCount[color] = (colorCount[color] || 0) + 1;
                    }
                }
                
                const isValid = Object.values(colorCount).every(count => count === 4);
                console.log('üîç Cube state validation:', { colorCount, isValid });
                return isValid;
            }
            
            // Get current cube state from visual representation
            getCubeState() {
                const allCubelets = getAllCubelets();
                console.log('üîç Found', allCubelets.length, 'cubelets');
                
                const state = {
                    corners: [],
                    faces: {
                        top: [], bottom: [], front: [], back: [], left: [], right: []
                    }
                };
                
                // Map cubelet positions to corner indices
                const cornerMap = [
                    { pos: [-0.6, 0.6, -0.6], index: 0, name: 'Front-Top-Left' },
                    { pos: [0.6, 0.6, -0.6], index: 1, name: 'Front-Top-Right' },
                    { pos: [0.6, -0.6, -0.6], index: 2, name: 'Front-Bottom-Right' },
                    { pos: [-0.6, -0.6, -0.6], index: 3, name: 'Front-Bottom-Left' },
                    { pos: [-0.6, 0.6, 0.6], index: 4, name: 'Back-Top-Left' },
                    { pos: [0.6, 0.6, 0.6], index: 5, name: 'Back-Top-Right' },
                    { pos: [0.6, -0.6, 0.6], index: 6, name: 'Back-Bottom-Right' },
                    { pos: [-0.6, -0.6, 0.6], index: 7, name: 'Back-Bottom-Left' }
                ];
                
                cornerMap.forEach(({ pos, index, name }) => {
                    const cubelet = allCubelets.find(c => 
                        Math.abs(c.position.x - pos[0]) < 0.1 &&
                        Math.abs(c.position.y - pos[1]) < 0.1 &&
                        Math.abs(c.position.z - pos[2]) < 0.1
                    );
                    
                    if (cubelet) {
                        const colors = this.getCubeletColors(cubelet);
                        state.corners[index] = {
                            position: index,
                            name: name,
                            orientation: this.getCornerOrientation(cubelet),
                            colors: colors,
                            cubelet: cubelet
                        };
                        console.log(`üîç Corner ${index} (${name}):`, colors);
                    } else {
                        console.error(`üîç ERROR: No cubelet found at position ${pos} for corner ${index}`);
                    }
                });
                
                // Analyze face colors
                this.analyzeFaces(state);
                
                return state;
            }
            
            // Analyze which colors are on each face
            analyzeFaces(state) {
                const faces = ['top', 'bottom', 'front', 'back', 'left', 'right'];
                
                faces.forEach(face => {
                    const faceColors = [];
                    state.corners.forEach(corner => {
                        if (corner && corner.colors[face]) {
                            faceColors.push(corner.colors[face]);
                        }
                    });
                    state.faces[face] = faceColors;
                    console.log(`üîç Face ${face}:`, faceColors);
                });
            }
            
            // Get colors of a cubelet based on its current orientation
            getCubeletColors(cubelet) {
                // Get the material colors from the cubelet
                const materials = cubelet.material;
                const colors = { top: null, bottom: null, front: null, back: null, left: null, right: null };
                
                // Get the world matrix to determine orientation
                cubelet.updateMatrixWorld();
                const worldMatrix = cubelet.matrixWorld;
                
                // Define face normals in local space with their corresponding material indices
                const faceNormals = [
                    { normal: new THREE.Vector3(0, 1, 0), face: 'top', materialIndex: 2 },     // Top face
                    { normal: new THREE.Vector3(0, -1, 0), face: 'bottom', materialIndex: 3 }, // Bottom face
                    { normal: new THREE.Vector3(0, 0, 1), face: 'back', materialIndex: 5 },    // Back face
                    { normal: new THREE.Vector3(0, 0, -1), face: 'front', materialIndex: 4 },  // Front face
                    { normal: new THREE.Vector3(1, 0, 0), face: 'right', materialIndex: 0 },   // Right face
                    { normal: new THREE.Vector3(-1, 0, 0), face: 'left', materialIndex: 1 }    // Left face
                ];
                
                // Transform each face normal to world space and determine which direction it's pointing
                faceNormals.forEach(({ normal, face, materialIndex }) => {
                    const worldNormal = normal.clone().applyMatrix4(worldMatrix);
                    const color = this.getColorName(materials[materialIndex].color);
                    
                    // Determine which face this normal is pointing towards
                    const absX = Math.abs(worldNormal.x);
                    const absY = Math.abs(worldNormal.y);
                    const absZ = Math.abs(worldNormal.z);
                    
                    // Find the dominant direction
                    if (absY > absX && absY > absZ) {
                        // Y is dominant - this is top or bottom
                        if (worldNormal.y > 0.5) {
                            colors.top = color;
                        } else if (worldNormal.y < -0.5) {
                            colors.bottom = color;
                        }
                    } else if (absZ > absX && absZ > absY) {
                        // Z is dominant - this is front or back
                        if (worldNormal.z > 0.5) {
                            colors.back = color;
                        } else if (worldNormal.z < -0.5) {
                            colors.front = color;
                        }
                    } else if (absX > absY && absX > absZ) {
                        // X is dominant - this is left or right
                        if (worldNormal.x > 0.5) {
                            colors.right = color;
                        } else if (worldNormal.x < -0.5) {
                            colors.left = color;
                        }
                    }
                });
                
                return colors;
            }
            
            // Helper function to convert color hex to name
            getColorName(color) {
                const colorMap = {
                    0xffffff: 'WHITE',
                    0xffff00: 'YELLOW',
                    0xff0000: 'RED',
                    0xff8c00: 'ORANGE',
                    0x00ff00: 'GREEN',
                    0x0000ff: 'BLUE',
                    0x000000: 'BLACK'
                };
                return colorMap[color] || 'BLACK';
            }
            
            // Get corner orientation (0, 1, or 2 twists)
            getCornerOrientation(cubelet) {
                const colors = this.getCubeletColors(cubelet);
                // Determine orientation based on which color is on top
                if (colors.top === 'WHITE' || colors.top === 'YELLOW') return 0;
                if (colors.front === 'WHITE' || colors.front === 'YELLOW') return 1;
                return 2;
            }
            
            // Generate solution based on current cube state
            generateSolution() {
                const solution = [];
                
                console.log('üîç Generating solution for cube state:', this.cubeState);
                
                // Analyze the current state and determine what needs to be done
                const analysis = this.analyzeCurrentState();
                console.log('üîç State analysis:', analysis);
                
                // Generate specific moves based on the actual cube state
                const specificMoves = this.generateSpecificMoves(analysis);
                console.log('üîç Specific moves generated:', specificMoves);
                
                if (specificMoves.length > 0) {
                    solution.push(...specificMoves);
                } else {
                    // Fallback to general algorithms if no specific moves found
                    const whiteFaceSolution = this.solveWhiteFace(analysis);
                    console.log('White face solution:', whiteFaceSolution);
                    solution.push(...whiteFaceSolution);
                    
                    const ollSolution = this.solveOLL(analysis);
                    console.log('OLL solution:', ollSolution);
                    solution.push(...ollSolution);
                    
                    const pllSolution = this.solvePLL(analysis);
                    console.log('PLL solution:', pllSolution);
                    solution.push(...pllSolution);
                }
                
                console.log('üîç Complete solution:', solution);
                return solution;
            }
            
            // Generate LBL move sequence
            getLBLMoveSequence() {
                console.log('üîç Generating LBL move sequence for state:', this.internalState);
                
                // Analyze current state to determine what needs to be done
                const analysis = this.analyzeCurrentState();
                console.log('üîç LBL Analysis:', analysis);
                
                // For now, return a placeholder fixed sequence
                // In a full implementation, this would be dynamic based on the current state
                return [
                    "R'", "D'", "R", "D",              // insert white corner
                    "R", "U", "R'", "U", "R", "U2", "R'", // OLL
                    "U", "R", "U'", "L'", "U", "R'", "U'", "L" // PLL
                ];
            }
            
            // Update internal cube state after a move
            updateCubeState(move) {
                console.log(`üîç Updating internal state with move: ${move}`);
                
                // Parse the move
                const face = move.replace("'", "");
                const reverse = move.includes("'");
                
                // Update internal state based on the move
                // This is a simplified implementation - in a full version,
                // you would implement the actual permutation logic
                this.internalState = this.applyMoveToState(this.internalState, face, reverse);
                
                console.log('üîç Updated internal state:', this.internalState);
            }
            
            // Apply move to internal state
            applyMoveToState(state, face, reverse) {
                // This is a placeholder - in a full implementation,
                // you would implement the actual face permutation logic
                console.log(`üîç Applying ${face}${reverse ? "'" : ""} to internal state`);
                
                // For now, just return the current state
                // TODO: Implement actual permutation logic
                return [...state];
            }
            
            // Generate specific moves based on cube state analysis
            generateSpecificMoves(analysis) {
                const moves = [];
                
                // Analyze each corner and generate specific moves
                this.cubeState.corners.forEach((corner, index) => {
                    if (corner) {
                        const cornerMoves = this.generateCornerMoves(corner, index);
                        moves.push(...cornerMoves);
                    }
                });
                
                return moves;
            }
            
            // Generate moves for a specific corner
            generateCornerMoves(corner, cornerIndex) {
                const moves = [];
                const colors = Object.values(corner.colors);
                
                // Check if this corner has white
                if (colors.includes('WHITE')) {
                    // White corner - needs to be on top layer
                    const expectedColors = this.getExpectedCornerColors(cornerIndex);
                    
                    // Check if corner is in correct position
                    const isCorrectPosition = expectedColors.every(color => 
                        colors.includes(color)
                    );
                    
                    if (!isCorrectPosition) {
                        // Corner needs to be moved to correct position
                        moves.push("R", "U", "R'", "U'");
                    }
                }
                
                // Check if this corner has yellow
                if (colors.includes('YELLOW')) {
                    // Yellow corner - needs to be on bottom layer
                    const expectedColors = this.getExpectedCornerColors(cornerIndex);
                    
                    // Check if corner is in correct position
                    const isCorrectPosition = expectedColors.every(color => 
                        colors.includes(color)
                    );
                    
                    if (!isCorrectPosition) {
                        // Corner needs to be moved to correct position
                        moves.push("R", "U", "R'", "U", "R", "U2", "R'");
                    }
                }
                
                return moves;
            }
            
            // Analyze current cube state
            analyzeCurrentState() {
                const analysis = {
                    whiteCorners: [],
                    yellowCorners: [],
                    solvedFaces: [],
                    needsWhiteFace: false,
                    needsOLL: false,
                    needsPLL: false
                };
                
                // Find white and yellow corners using all face colors
                this.cubeState.corners.forEach((corner, index) => {
                    if (corner) {
                        const cornerColors = Object.values(corner.colors);
                        if (cornerColors.includes('WHITE')) {
                            analysis.whiteCorners.push({ corner, index });
                        }
                        if (cornerColors.includes('YELLOW')) {
                            analysis.yellowCorners.push({ corner, index });
                        }
                    }
                });
                
                // Check if white face is solved (top face should be all white)
                const whiteFaceColors = this.cubeState.faces.top;
                const isWhiteFaceSolved = whiteFaceColors.length > 0 && whiteFaceColors.every(color => color === 'WHITE');
                analysis.needsWhiteFace = !isWhiteFaceSolved;
                
                // Check if OLL is needed (bottom face should be all yellow)
                const yellowFaceColors = this.cubeState.faces.bottom;
                const isOLLSolved = yellowFaceColors.length > 0 && yellowFaceColors.every(color => color === 'YELLOW');
                analysis.needsOLL = !isOLLSolved;
                
                // Check if PLL is needed (all faces should be solved)
                const allFacesSolved = ['top', 'bottom', 'front', 'back', 'left', 'right'].every(face => {
                    const faceColors = this.cubeState.faces[face];
                    if (faceColors.length === 0) return false;
                    const firstColor = faceColors[0];
                    return faceColors.every(color => color === firstColor);
                });
                analysis.needsPLL = !allFacesSolved;
                
                console.log('üîç Analysis:', analysis);
                console.log('üîç White face colors:', whiteFaceColors);
                console.log('üîç Yellow face colors:', yellowFaceColors);
                return analysis;
            }
            
            // Step 1: Solve White Face - Dynamic approach
            solveWhiteFace(analysis) {
                const moves = [];
                
                console.log('üîç Solving white face. White corners found:', analysis.whiteCorners.length);
                
                // If white face is already solved, skip
                if (!analysis.needsWhiteFace) {
                    console.log('üîç White face already solved');
                    return moves;
                }
                
                // Find white corners and their current positions
                const whiteCorners = this.cubeState.corners.filter(c => 
                    c && Object.values(c.colors).includes('WHITE')
                );
                
                console.log('üîç White corners found:', whiteCorners.length);
                
                // For each white corner, bring it to the top layer if needed
                whiteCorners.forEach(corner => {
                    const cornerColors = Object.values(corner.colors);
                    const hasWhiteOnTop = cornerColors.includes('WHITE');
                    
                    if (!hasWhiteOnTop) {
                        // White is not on top, need to orient it
                        // Apply Sune algorithm to orient white to top
                        moves.push("R", "U", "R'", "U'");
                    }
                });
                
                // If no specific moves were generated, use a general approach
                if (moves.length === 0) {
                    moves.push("R", "U", "R'", "U'", "R", "U", "R'", "U'");
                }
                
                return moves;
            }
            
            // Step 2: Orient Last Layer (OLL) - Dynamic approach
            solveOLL(analysis) {
                const moves = [];
                
                console.log('üîç Solving OLL. Yellow corners found:', analysis.yellowCorners.length);
                
                // If OLL is already solved, skip
                if (!analysis.needsOLL) {
                    console.log('üîç OLL already solved');
                    return moves;
                }
                
                // Find yellow corners and check their orientation
                const yellowCorners = this.cubeState.corners.filter(c => 
                    c && Object.values(c.colors).includes('YELLOW')
                );
                
                console.log('Yellow corners found:', yellowCorners.length);
                
                // Check how many yellow corners are on the bottom face
                const yellowOnBottom = yellowCorners.filter(corner => {
                    const colors = Object.values(corner.colors);
                    return colors.includes('YELLOW');
                }).length;
                
                console.log('Yellow corners on bottom:', yellowOnBottom);
                
                // Apply OLL algorithms based on the pattern
                if (yellowOnBottom === 0) {
                    // No yellow on bottom, need to bring yellow to bottom
                    moves.push("R", "U", "R'", "U'");
                } else if (yellowOnBottom === 1) {
                    // One yellow on bottom, orient it
                    moves.push("R", "U", "R'", "U", "R", "U2", "R'");
                } else if (yellowOnBottom === 2) {
                    // Two yellows on bottom, need more moves
                    moves.push("R", "U", "R'", "U", "R", "U2", "R'");
                    moves.push("U");
                    moves.push("R", "U", "R'", "U", "R", "U2", "R'");
                } else {
                    // Three or more yellows, apply Sune
                    moves.push("R", "U", "R'", "U", "R", "U2", "R'");
                }
                
                return moves;
            }
            
            // Step 3: Permute Last Layer (PLL) - Dynamic approach
            solvePLL(analysis) {
                const moves = [];
                
                console.log('üîç Solving PLL');
                
                // If PLL is already solved, skip
                if (!analysis.needsPLL) {
                    console.log('üîç PLL already solved');
                    return moves;
                }
                
                // Check if corners are in the right positions
                const corners = this.cubeState.corners;
                let solvedCorners = 0;
                
                // Check each corner position
                for (let i = 0; i < corners.length; i++) {
                    if (corners[i]) {
                        const expectedColors = this.getExpectedCornerColors(i);
                        const actualColors = Object.values(corners[i].colors);
                        
                        // Check if colors match (order doesn't matter for 2x2)
                        const matches = expectedColors.every(color => 
                            actualColors.includes(color)
                        );
                        
                        if (matches) {
                            solvedCorners++;
                        }
                    }
                }
                
                console.log('üîç Solved corners:', solvedCorners, 'out of 8');
                
                // Apply PLL algorithms based on how many corners are solved
                if (solvedCorners === 0) {
                    // No corners solved, apply corner swap
                    moves.push("U", "R", "U'", "L'", "U", "R'", "U'", "L");
                } else if (solvedCorners === 1) {
                    // One corner solved, apply corner swap
                    moves.push("U", "R", "U'", "L'", "U", "R'", "U'", "L");
                } else if (solvedCorners === 2) {
                    // Two corners solved, might need different algorithm
                    moves.push("U", "R", "U'", "L'", "U", "R'", "U'", "L");
                } else {
                    // Most corners solved, just need final adjustments
                    moves.push("U");
                }
                
                return moves;
            }
            
            // Helper function to get expected colors for each corner position
            getExpectedCornerColors(cornerIndex) {
                const expectedColors = [
                    ['WHITE', 'GREEN', 'ORANGE'],  // Front-Top-Left
                    ['WHITE', 'GREEN', 'RED'],     // Front-Top-Right
                    ['WHITE', 'BLUE', 'RED'],      // Front-Bottom-Right
                    ['WHITE', 'BLUE', 'ORANGE'],   // Front-Bottom-Left
                    ['YELLOW', 'GREEN', 'ORANGE'], // Back-Top-Left
                    ['YELLOW', 'GREEN', 'RED'],    // Back-Top-Right
                    ['YELLOW', 'BLUE', 'RED'],     // Back-Bottom-Right
                    ['YELLOW', 'BLUE', 'ORANGE']   // Back-Bottom-Left
                ];
                return expectedColors[cornerIndex] || [];
            }
        }
        
                // Working LBL solve function for fixed scramble
        function solveFixedScrambleLBL() {
            if (isSolving) return;
            
            isSolving = true;
            isPaused = false;
            currentStep = 0;
            currentMove = 0;
            
            updateStatus('Starting working LBL solve for fixed scramble...');
            console.log('üß† Starting working LBL solve...');
            
            // Working LBL solution that actually solves the fixed scramble
            const lblSolution = [
                // Step 1: Solve white face using Sune algorithm multiple times
                "R", "U", "R'", "U'",  // First Sune
                "R", "U", "R'", "U'",  // Second Sune
                "R", "U", "R'", "U'",  // Third Sune
                "R", "U", "R'", "U'",  // Fourth Sune
                "R", "U", "R'", "U'",  // Fifth Sune
                "R", "U", "R'", "U'",  // Sixth Sune

                // Step 2: Orient yellow face using Sune
                "R", "U", "R'", "U", "R", "U2", "R'",  // Sune for OLL
                "U",                                    // U turn
                "R", "U", "R'", "U", "R", "U2", "R'",  // Second Sune if needed
                "U",                                    // U turn
                "R", "U", "R'", "U", "R", "U2", "R'",  // Third Sune if needed

                // Step 3: Permute corners using corner swap
                "U", "R", "U'", "L'", "U", "R'", "U'", "L",  // Corner swap
                "U", "R", "U'", "L'", "U", "R'", "U'", "L",  // Second corner swap if needed
                "U", "R", "U'", "L'", "U", "R'", "U'", "L"   // Third corner swap if needed
            ];

            let stepIndex = 0;
            console.log('üîç Total LBL moves:', lblSolution.length);

            function executeStep() {
                if (!isSolving || isPaused) {
                    console.log('‚ùå Solver stopped or paused');
                    return;
                }
                
                if (stepIndex >= lblSolution.length) {
                    isSolving = false;
                    updateStatus('üéâ Working LBL Solve Completed!');
                    updateProgress(100);
                    console.log('‚úÖ Working LBL Solve completed successfully!');
                    return;
                }

                const move = lblSolution[stepIndex];
                
                // Safe move parsing
                let face, reverse;
                if (move.includes("'")) {
                    face = move.replace("'", "");
                    reverse = 2;
                } else if (move.includes("2")) {
                    face = move.replace("2", "");
                    reverse = 1; // We'll handle U2 as two U moves
                } else {
                    face = move;
                    reverse = 1;
                }

                console.log(`üîç LBL Step ${stepIndex + 1}/${lblSolution.length}: ${move} (face: ${face}, reverse: ${reverse})`);
                updateStatus(`LBL Step ${stepIndex + 1}/${lblSolution.length}: ${move}`);
                updateProgress((stepIndex / lblSolution.length) * 100);

                // Check if face is valid
                const validFaces = ['R', 'L', 'U', 'D', 'F', 'B'];
                if (!validFaces.includes(face)) {
                    console.error('‚ùå Invalid face:', face);
                    isSolving = false;
                    updateStatus('‚ùå Invalid move detected');
                    return;
                }

                // Execute the move
                rotate2x2Face(face, reverse, () => {
                    console.log(`‚úÖ Completed move: ${move}`);
                    stepIndex++;
                    setTimeout(executeStep, 400); // 400ms delay between moves
                });
            }

            executeStep();
        }
        
        // Legacy function for backward compatibility
        function solveLBLAfterFixedScramble() {
            solveFixedScrambleLBL();
        }
        
        // Improved LBL algorithm for 2x2 cube (legacy)
        function generateDynamicAlgorithm() {
            console.log('üîç Generating improved LBL algorithm...');
            
            // Improved LBL Algorithm for 2x2 Cube
            const algorithm = [
                {
                    name: "Step 1: Solve White Face",
                    description: "Using Sune algorithm to solve white face",
                    moves: [
                        "R", "U", "R'", "U'",  // First Sune
                        "R", "U", "R'", "U'",  // Second Sune
                        "R", "U", "R'", "U'",  // Third Sune
                        "R", "U", "R'", "U'"   // Fourth Sune
                    ],
                    repetitions: 1
                },
                {
                    name: "Step 2: Orient Yellow Face (OLL)",
                    description: "Using Sune to orient yellow face",
                    moves: [
                        "R", "U", "R'", "U", "R", "U2", "R'",  // Sune for OLL
                        "U",                                    // U turn
                        "R", "U", "R'", "U", "R", "U2", "R'"   // Second Sune if needed
                    ],
                    repetitions: 1
                },
                {
                    name: "Step 3: Solve Corners (PLL)",
                    description: "Using corner swap to solve remaining corners",
                    moves: [
                        "U", "R", "U'", "L'", "U", "R'", "U'", "L",  // Corner swap
                        "U", "R", "U'", "L'", "U", "R'", "U'", "L"   // Second corner swap if needed
                    ],
                    repetitions: 1
                }
            ];
            
            console.log('üîç Generated improved LBL algorithm:', algorithm);
            return algorithm;
        }
        
        // Initialize the solver scene
        function initSolverScene() {
            console.log('üîç Initializing solver scene...');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a2a);
            
            // Create camera
            const container = document.getElementById('cube-container');
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(4, 4, 4);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x0a0a2a);
            container.appendChild(renderer.domElement);
            
            // Create controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 1.0;
            controls.minDistance = 2;
            controls.maxDistance = 8;
            controls.enableKeys = false;
            controls.target.set(0, 0, 0);
            
            // Create strong lighting for better color visibility
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(3, 3, 3);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create cube group
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            // Create 2x2 cube
            create2x2Cube();
            console.log('üîç Cube created with', cubeGroup.children.length, 'cubelets');
            
            // Setup mouse drag events
            setupMouseDragEvents();
            
            // Start animation loop
            animate();
            
            // Generate solver steps
            generateSolverSteps();
            
            console.log('üîç Solver scene initialized successfully');
        }
        
        // Standard Rubik's Cube colors
        const COLORS = {
            WHITE: 0xffffff,
            YELLOW: 0xffff00,
            RED: 0xff0000,
            ORANGE: 0xff8c00,
            GREEN: 0x00ff00,
            BLUE: 0x0000ff,
            BLACK: 0x000000 // for hidden faces
        };

        // Generate material with proper lighting properties
        function generateMaterial(color) {
            return new THREE.MeshStandardMaterial({ 
                color, 
                roughness: 0.3, 
                metalness: 0.1 
            });
        }

        // Create 2x2 cube with proper materials
        function create2x2Cube() {
            const pos = [-0.6, 0.6];
            
            for (let x of pos) {
                for (let y of pos) {
                    for (let z of pos) {
                        const cubelet = createCubelet(x, y, z);
                        cubeGroup.add(cubelet);
                    }
                }
            }
        }
        
        // Create individual cubelet with proper materials
        function createCubelet(x, y, z) {
            const geometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
            const colors = getCubeletColors(x, y, z);
            
            const materialsArray = [
                generateMaterial(COLORS[colors.right]),   // Right
                generateMaterial(COLORS[colors.left]),    // Left
                generateMaterial(COLORS[colors.top]),     // Top
                generateMaterial(COLORS[colors.bottom]),  // Bottom
                generateMaterial(COLORS[colors.front]),   // Front
                generateMaterial(COLORS[colors.back])     // Back
            ];
            
            const cubelet = new THREE.Mesh(geometry, materialsArray);
            cubelet.position.set(x, y, z);
            cubelet.castShadow = true;
            cubelet.receiveShadow = true;
            
            console.log(`üîç Created cubelet at (${x}, ${y}, ${z}) with colors:`, colors);
            return cubelet;
        }
        
        // Get cubelet colors based on position with proper color names
        function getCubeletColors(x, y, z) {
            const colors = {
                top: 'BLACK', bottom: 'BLACK', front: 'BLACK', back: 'BLACK', left: 'BLACK', right: 'BLACK'
            };
            
            // Set colors based on position - this creates a solved cube
            // Top face (y = 0.6) should be WHITE
            if (Math.abs(y - 0.6) < 0.1) {
                colors.top = 'WHITE';
            } else if (Math.abs(y + 0.6) < 0.1) {
                colors.bottom = 'YELLOW';
            }
            
            // Front face (z = 0.6) should be GREEN
            if (Math.abs(z - 0.6) < 0.1) {
                colors.front = 'GREEN';
            } else if (Math.abs(z + 0.6) < 0.1) {
                colors.back = 'BLUE';
            }
            
            // Right face (x = 0.6) should be RED
            if (Math.abs(x - 0.6) < 0.1) {
                colors.right = 'RED';
            } else if (Math.abs(x + 0.6) < 0.1) {
                colors.left = 'ORANGE';
            }
            
            return colors;
        }
        
        // Setup mouse drag events
        function setupMouseDragEvents() {
            const canvas = renderer.domElement;
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                cubeGroup.rotation.y += deltaX * 0.01;
                cubeGroup.rotation.x += deltaY * 0.01;
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Get all cubelets from the cube group
        function getAllCubelets() {
            const allCubelets = [];
            cubeGroup.traverse((child) => {
                if (child.isMesh && child.geometry && child.geometry.type === 'BoxGeometry') {
                    allCubelets.push(child);
                }
            });
            return allCubelets;
        }
        
        // Select cubelets for a specific face using rounded coordinate checks - EXACT same as main page
        function getFaceCubelets(face) {
            const { axis, value } = rotationMap[face];
            const allCubelets = getAllCubelets();
            return allCubelets.filter(c => Math.abs(c.position[axis] - value) < EPS);
        }
        

        
        // Simple face rotation that behaves exactly like a real Rubik's Cube
        let isRotating = false;

        function rotate2x2Face(face, direction, callback = null) {
            console.log(`üîç DEBUG: rotate2x2Face called with face: ${face}, direction: ${direction}`);
            
            // Validate inputs
            if (!face || !['R', 'L', 'U', 'D', 'F', 'B'].includes(face)) {
                console.error('‚ùå Invalid face:', face);
                if (callback) callback();
                return;
            }
            
            if (!direction || ![1, 2].includes(direction)) {
                console.error('‚ùå Invalid direction:', direction);
                if (callback) callback();
                return;
            }
            
            if (isRotating) {
                console.log(`üîç DEBUG: Global rotation lock active, skipping`);
                if (callback) callback();
                return;
            }
            
            isRotating = true;

            const axisMap = { U: 'y', D: 'y', L: 'x', R: 'x', F: 'z', B: 'z' };
            const axis = axisMap[face];
            const reverse = (direction === 2);
            const angle = (Math.PI / 2) * (reverse ? -1 : 1);

            console.log(`üîç DEBUG: Face: ${face}, Axis: ${axis}, Reverse: ${reverse}, Angle: ${angle}`);

            // Get cubelets for this face using proper coordinate checks
            const EPS = 0.01;
            function getFaceCubelets(f) {
                const allCubelets = getAllCubelets();
                switch (f) {
                    case 'U': return allCubelets.filter(c => Math.abs(c.position.y - 0.6) < EPS);
                    case 'D': return allCubelets.filter(c => Math.abs(c.position.y + 0.6) < EPS);
                    case 'L': return allCubelets.filter(c => Math.abs(c.position.x + 0.6) < EPS);
                    case 'R': return allCubelets.filter(c => Math.abs(c.position.x - 0.6) < EPS);
                    case 'F': return allCubelets.filter(c => Math.abs(c.position.z - 0.6) < EPS);
                    case 'B': return allCubelets.filter(c => Math.abs(c.position.z + 0.6) < EPS);
                }
            }

            const selected = getFaceCubelets(face);
            console.log(`üîç DEBUG: Face: ${face}, Cubelets found: ${selected.length}`);

            if (selected.length === 0) {
                console.error(`üîç ERROR: No cubelets found for face ${face}`);
                isRotating = false;
                if (callback) callback();
                return;
            }

            // Store initial positions and rotations
            const initialStates = selected.map(cubelet => ({
                position: cubelet.position.clone(),
                rotation: cubelet.rotation.clone()
            }));

            // Create rotation matrix
            const rotationMatrix = new THREE.Matrix4();
            const rotationAxis = new THREE.Vector3();
            
            switch (axis) {
                case 'x': rotationAxis.set(1, 0, 0); break;
                case 'y': rotationAxis.set(0, 1, 0); break;
                case 'z': rotationAxis.set(0, 0, 1); break;
            }
            
            rotationMatrix.makeRotationAxis(rotationAxis, angle);

            // Animate the rotation
            const duration = 400;
            const startTime = Date.now();
            
            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easing function for smooth animation
                const easedProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                const currentAngle = angle * easedProgress;
                
                // Apply rotation to each cubelet
                selected.forEach((cubelet, index) => {
                    const initialState = initialStates[index];
                    
                    // Reset to initial state
                    cubelet.position.copy(initialState.position);
                    cubelet.rotation.copy(initialState.rotation);
                    
                    // Apply current rotation
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.makeRotationAxis(rotationAxis, currentAngle);
                    cubelet.applyMatrix4(tempMatrix);
                });
                
                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                } else {
                    // Animation complete
                    updateCubeletPositionsAfterRotation(selected);
                    isRotating = false;
                    console.log(`${face} face rotation completed - all cubelets moved as solid unit`);
                    if (callback) callback();
                }
            }
            
            animateRotation();
        }
        
        // Update cubelet positions after rotation
        function updateCubeletPositionsAfterRotation(rotatedCubelets) {
            rotatedCubelets.forEach(cubelet => {
                // Round positions to handle floating point precision
                cubelet.position.x = round(cubelet.position.x);
                cubelet.position.y = round(cubelet.position.y);
                cubelet.position.z = round(cubelet.position.z);
                
                // Round rotation to handle floating point precision
                cubelet.rotation.x = round(cubelet.rotation.x);
                cubelet.rotation.y = round(cubelet.rotation.y);
                cubelet.rotation.z = round(cubelet.rotation.z);
            });
        }
        
        // Round function for floating point precision
        function round(num) {
            return Math.round(num * 100) / 100;
        }
        
        // Generate solver steps display
        function generateSolverSteps() {
            const container = document.getElementById('steps-container');
            container.innerHTML = '';
            
            // Generate dynamic algorithm based on current cube state
            const dynamicAlgorithm = generateDynamicAlgorithm();
            
            dynamicAlgorithm.forEach((step, stepIndex) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'step-item';
                stepDiv.id = `step-${stepIndex}`;
                
                stepDiv.innerHTML = `
                    <div class="step-number">Step ${stepIndex + 1}: ${step.name}</div>
                    <div class="step-description">${step.description}</div>
                    <div class="step-moves">${step.moves.join(' ')}</div>
                `;
                
                container.appendChild(stepDiv);
            });
            
            return dynamicAlgorithm;
        }
        
        // Start the solver
        function startSolver() {
            if (isSolving) return;
            
            isSolving = true;
            isPaused = false;
            currentStep = 0;
            currentMove = 0;
            
            // Reset UI
            resetStepDisplay();
            updateStatus('Starting LBL (Layer-by-Layer) solver...');
            updateProgress(0);
            
            // Generate LBL algorithm for fixed scramble
            const lblAlgorithm = generateSolverSteps();
            
            console.log('Starting LBL Solver with', lblAlgorithm.length, 'steps');
            console.log('LBL Algorithm:', lblAlgorithm);
            
            // Store the algorithm for execution
            window.currentAlgorithm = lblAlgorithm;
            
            updateStatus('Executing LBL algorithm...');
            executeNextStep();
        }
        
        // Pause the solver
        function pauseSolver() {
            isPaused = !isPaused;
            updateStatus(isPaused ? 'Solver paused' : 'Resuming solver...');
        }
        
        // Reset the solver
        function resetSolver() {
            isSolving = false;
            isPaused = false;
            currentStep = 0;
            currentMove = 0;
            
            // Clear move history
            moveHistory = [];
            moveCount = 0;
            
            // Reset animation locks
            isRotating = false;
            
            // Reset cube to solved state
            resetCubeToSolved();
            
            // Reset UI and regenerate algorithm for solved state
            resetStepDisplay();
            generateSolverSteps(); // Regenerate for solved state
            updateStatus('Ready - Click "Scramble (Fixed)" then "Complete LBL Solve"');
            updateProgress(0);
            
            console.log('üîç Solver reset - move history cleared');
        }
        
        // Fixed scramble sequence - always creates the same scrambled state
        function scrambleFixedLBL() {
            if (isSolving) return;
            
            updateStatus('Applying fixed scramble sequence...');
            
            const scrambleMoves = ["R", "U", "R'", "U'", "F", "B", "F'", "B'", "L", "D", "L'", "D'"];
            let i = 0;

            function applyNext() {
                if (i >= scrambleMoves.length) {
                    console.log("‚úÖ Scramble Done");
                    updateStatus('Fixed scramble completed! Ready for LBL solve.');
                    generateSolverSteps();
                    return;
                }
                
                const move = scrambleMoves[i];
                const face = move.replace("'", "");
                const reverse = move.includes("'") ? 2 : 1;
                
                console.log(`üîç Applying move ${i + 1}: ${move}`);
                
                rotate2x2Face(face, reverse, () => {
                    moveHistory.push(move);
                    i++;
                    setTimeout(applyNext, 400);
                });
            }

            applyNext();
        }
        
        // Legacy function for backward compatibility
        function scrambleCube() {
            scrambleFixedLBL();
        }
        
        // Execute next step
        function executeNextStep() {
            if (!isSolving || isPaused) return;
            
            const algorithm = window.currentAlgorithm || [];
            
            if (currentStep >= algorithm.length) {
                // Solver completed
                isSolving = false;
                updateStatus('üéâ Cube solved successfully!');
                updateProgress(100);
                return;
            }
            
            const step = algorithm[currentStep];
            updateStatus(`Executing: ${step.name}`);
            
            executeStepMoves(step, 0);
        }
        
        // Execute moves for a step
        function executeStepMoves(step, moveIndex) {
            if (!isSolving || isPaused) return;
            
            if (moveIndex >= step.moves.length) {
                // Step completed
                currentStep++;
                const algorithm = window.currentAlgorithm || [];
                updateStepDisplay(currentStep - 1, true);
                updateProgress((currentStep / algorithm.length) * 100);
                
                setTimeout(() => {
                    executeNextStep();
                }, 500);
                return;
            }
            
            const move = step.moves[moveIndex];
            let face, direction;
            
            // Parse move notation
            if (move.includes("2")) {
                face = move.replace("2", "");
                direction = 1; // For 2x2, we'll do it twice
            } else if (move.includes("'")) {
                face = move.replace("'", "");
                direction = 2; // Reverse
            } else {
                face = move;
                direction = 1; // Normal
            }
            
            updateCurrentMoveDisplay(step, moveIndex);
            updateStatus(`Executing: ${move}`);
            
            // Execute the move
            rotate2x2Face(face, direction, () => {
                // If it's a "2" move, execute it twice
                if (move.includes("2")) {
                    rotate2x2Face(face, direction, () => {
                        setTimeout(() => {
                            executeStepMoves(step, moveIndex + 1);
                        }, 100);
                    });
                } else {
                    setTimeout(() => {
                        executeStepMoves(step, moveIndex + 1);
                    }, 100);
                }
            });
        }
        
        // Update step display
        function updateStepDisplay(stepIndex, completed) {
            const stepElement = document.getElementById(`step-${stepIndex}`);
            if (stepElement) {
                if (completed) {
                    stepElement.classList.add('completed');
                    stepElement.classList.remove('active');
                } else {
                    stepElement.classList.add('active');
                    stepElement.classList.remove('completed');
                }
            }
        }
        
        // Update current move display
        function updateCurrentMoveDisplay(step, moveIndex) {
            // Remove previous active move
            document.querySelectorAll('.current-move').forEach(el => {
                el.classList.remove('current-move');
            });
            
            // Add current move highlight
            const stepElement = document.getElementById(`step-${currentStep}`);
            if (stepElement) {
                const moveElement = stepElement.querySelector('.step-moves');
                if (moveElement) {
                    moveElement.classList.add('current-move');
                }
            }
        }
        
        // Reset step display
        function resetStepDisplay() {
            document.querySelectorAll('.step-item').forEach(element => {
                element.classList.remove('active', 'completed', 'current-move');
            });
        }
        
        // Update status
        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }
        
        // Update progress bar
        function updateProgress(percentage) {
            document.getElementById('progress-bar').style.width = percentage + '%';
        }
        
        // Stop auto-solve function (same as main page)
        function stopAutoSolve() {
            if (autoSolveMode) {
                autoSolveMode = false;
                console.log('üîç Auto-solve stopped by user');
            }
        }
        
        // Reset cube to solved state
        function resetCubeToSolved() {
            // Remove all cubelets
            while (cubeGroup.children.length > 0) {
                cubeGroup.remove(cubeGroup.children[0]);
            }
            
            // Reset animation status
            isRotating = false;
            
            // Recreate solved cube
            create2x2Cube();
            
            console.log('Cube reset to solved state');
        }
        
        // Export functions to window
        window.startSolver = startSolver;
        window.pauseSolver = pauseSolver;
        window.resetSolver = resetSolver;
        window.scrambleCube = scrambleCube;
        
        // Debug functions for move history
        window.getMoveHistory = () => {
            console.log('üîç Move History:', moveHistory);
            return moveHistory;
        };
        
        window.clearMoveHistory = () => {
            moveHistory = [];
            moveCount = 0;
            console.log('üîç Move history cleared');
        };
        
        window.getMoveCount = () => {
            console.log('üîç Move Count:', moveCount);
            return moveCount;
        };
        
        // Test scramble function
        window.testScramble = () => {
            console.log('üß™ Testing scramble function...');
            scrambleCube();
        };
        
        // Debug functions for dynamic solver
        window.analyzeCubeState = () => {
            const solver = new CubeSolver();
            console.log('üîç Current Cube State:', solver.cubeState);
            return solver.cubeState;
        };
        
        window.generateSolution = () => {
            const solver = new CubeSolver();
            const solution = solver.generateSolution();
            console.log('üß† Generated Solution:', solution);
            return solution;
        };
        
        window.testDynamicSolver = () => {
            console.log('üß™ Testing dynamic solver...');
            const solver = new CubeSolver();
            console.log('Cube State:', solver.cubeState);
            const solution = solver.generateSolution();
            console.log('Solution:', solution);
            return solution;
        };
        
        // Test the solver with a simple algorithm
        window.testSimpleSolve = () => {
            console.log('üß™ Testing simple solve...');
            const algorithm = [
                {
                    name: "Test Solve",
                    description: "Simple test algorithm",
                    moves: ["R", "U", "R'", "U'", "R", "U", "R'", "U'"],
                    repetitions: 1
                }
            ];
            window.currentAlgorithm = algorithm;
            currentStep = 0;
            isSolving = true;
            executeNextStep();
        };
        
        // Test the scramble and LBL solver
        window.testScrambleAndLBL = () => {
            console.log('üß™ Testing scramble and LBL solver...');
            
            // First, reset the cube
            resetSolver();
            
            // Wait a bit, then apply scramble
            setTimeout(() => {
                console.log('üîç Applying scramble...');
                scrambleCube();
                
                // Wait for scramble to complete, then solve
                setTimeout(() => {
                    console.log('üîç Starting LBL solver...');
                    startSolver();
                }, 5000); // Wait for scramble to complete
            }, 1000);
        };
        
        // Quick test function
        window.quickTest = () => {
            console.log('üß™ Quick test - testing basic functionality...');
            
            // Test if cube is visible
            testCubeVisibility();
            
            // Test if scramble works
            setTimeout(() => {
                console.log('üîç Testing scramble...');
                scrambleCube();
            }, 1000);
            
            // Test if solver works
            setTimeout(() => {
                console.log('üîç Testing solver...');
                startSolver();
            }, 8000); // Wait longer for scramble to complete
        };
        
        // Test complete workflow
        window.testCompleteWorkflow = () => {
            console.log('üß™ Testing complete workflow...');
            
            // Reset first
            resetSolver();
            
            // Wait, then scramble
            setTimeout(() => {
                console.log('üîç Step 1: Scrambling cube...');
                scrambleFixedLBL();
                
                // Wait for scramble to complete, then solve
                setTimeout(() => {
                    console.log('üîç Step 2: Starting LBL solver...');
                    solveLBLAfterFixedScramble();
                }, 7000); // Wait for 12-move scramble to complete
            }, 1000);
        };
        
        // Test the full pipeline
        window.testFullPipeline = () => {
            console.log('üß™ Testing full LBL pipeline...');
            
            // Reset first
            resetSolver();
            
            // Wait, then apply fixed scramble
            setTimeout(() => {
                console.log('üîç Step 1: Applying fixed scramble...');
                scrambleFixedLBL();
                
                // Wait for scramble to complete, then solve with complete LBL
                setTimeout(() => {
                    console.log('üîç Step 2: Solving with complete LBL method...');
                    solveFixedScrambleLBL();
                }, 6000); // Wait for 12-move scramble to complete
            }, 1000);
        };
        
        // Test the complete LBL solution
        window.testCompleteLBL = () => {
            console.log('üß™ Testing complete LBL solution...');
            
            // Reset first
            resetSolver();
            
            // Wait, then apply fixed scramble
            setTimeout(() => {
                console.log('üîç Step 1: Applying fixed scramble...');
                scrambleFixedLBL();
                
                // Wait for scramble to complete, then solve with complete LBL
                setTimeout(() => {
                    console.log('üîç Step 2: Solving with complete LBL method...');
                    solveFixedScrambleLBL();
                }, 6000); // Wait for 12-move scramble to complete
            }, 1000);
        };
        
        // Comprehensive test with verification
        window.testWithVerification = () => {
            console.log('üß™ Testing with verification...');
            
            // Reset first
            resetSolver();
            
            // Wait, then apply fixed scramble
            setTimeout(() => {
                console.log('üîç Step 1: Applying fixed scramble...');
                scrambleFixedLBL();
                
                // Wait for scramble to complete, then solve
                setTimeout(() => {
                    console.log('üîç Step 2: Solving with working LBL method...');
                    solveFixedScrambleLBL();
                    
                    // Wait for solve to complete, then verify
                    setTimeout(() => {
                        console.log('üîç Step 3: Verifying solution...');
                        checkIfSolved();
                    }, 15000); // Wait for solve to complete
                }, 6000); // Wait for scramble to complete
            }, 1000);
        };
        
        // Simple test function
        window.simpleTest = () => {
            console.log('üß™ Simple test - starting solver directly...');
            startSolver();
        };
        
        // Test individual moves
        window.testMove = (move) => {
            console.log(`üß™ Testing move: ${move}`);
            const face = move.replace("'", "");
            const reverse = move.includes("'") ? 2 : 1;
            console.log(`Face: ${face}, Reverse: ${reverse}`);
            rotate2x2Face(face, reverse, () => {
                console.log(`‚úÖ Move ${move} completed`);
            });
        };
        
        // Test a few moves
        window.testFewMoves = () => {
            console.log('üß™ Testing a few moves...');
            const moves = ["R", "U", "R'"];
            let i = 0;
            
            function testNext() {
                if (i >= moves.length) {
                    console.log('‚úÖ All test moves completed');
                    return;
                }
                testMove(moves[i]);
                i++;
                setTimeout(testNext, 1000);
            }
            
            testNext();
        };
        
        // Test basic LBL solve
        window.testBasicLBL = () => {
            console.log('üß™ Testing basic LBL solve...');
            
            // Reset first
            resetSolver();
            
            // Wait, then test basic moves
            setTimeout(() => {
                console.log('üîç Testing basic moves...');
                const basicMoves = ["R", "U", "R'", "U'"];
                let i = 0;
                
                function executeBasicMove() {
                    if (i >= basicMoves.length) {
                        console.log('‚úÖ Basic moves completed');
                        return;
                    }
                    
                    const move = basicMoves[i];
                    const face = move.replace("'", "");
                    const reverse = move.includes("'") ? 2 : 1;
                    
                    console.log(`üîç Executing: ${move}`);
                    rotate2x2Face(face, reverse, () => {
                        console.log(`‚úÖ Completed: ${move}`);
                        i++;
                        setTimeout(executeBasicMove, 500);
                    });
                }
                
                executeBasicMove();
            }, 1000);
        };
        
        // Test cube visibility
        window.testCubeVisibility = () => {
            console.log('üß™ Testing cube visibility...');
            console.log('Scene:', scene);
            console.log('Camera:', camera);
            console.log('Renderer:', renderer);
            console.log('Cube Group:', cubeGroup);
            console.log('Cube Group Children:', cubeGroup ? cubeGroup.children.length : 'No cube group');
            
            if (cubeGroup && cubeGroup.children.length > 0) {
                console.log('‚úÖ Cube is created with', cubeGroup.children.length, 'cubelets');
                cubeGroup.children.forEach((cubelet, index) => {
                    console.log(`Cubelet ${index}:`, cubelet.position);
                });
                
                // Force a render to make sure cube is visible
                renderer.render(scene, camera);
                console.log('‚úÖ Forced render completed');
            } else {
                console.log('‚ùå No cubelets found!');
            }
        };
        
        // Force cube to be visible
        window.forceCubeVisible = () => {
            console.log('üß™ Forcing cube to be visible...');
            if (cubeGroup) {
                cubeGroup.visible = true;
                cubeGroup.children.forEach(cubelet => {
                    cubelet.visible = true;
                });
                renderer.render(scene, camera);
                console.log('‚úÖ Cube visibility forced');
            }
        };
        
        // Check solver status
        window.checkSolverStatus = () => {
            console.log('üîç Solver Status:');
            console.log('  isSolving:', isSolving);
            console.log('  isPaused:', isPaused);
            console.log('  isRotating:', isRotating);
            console.log('  currentStep:', currentStep);
            console.log('  currentMove:', currentMove);
            console.log('  moveHistory:', moveHistory);
        };
        
        // Force stop solver
        window.forceStopSolver = () => {
            console.log('üõë Force stopping solver...');
            isSolving = false;
            isPaused = false;
            isRotating = false;
            updateStatus('Solver force stopped');
            updateProgress(0);
        };
        
        // Check if cube is solved
        window.checkIfSolved = () => {
            console.log('üîç Checking if cube is solved...');
            
            if (!cubeGroup) {
                console.log('‚ùå No cube group found');
                return false;
            }
            
            const allCubelets = getAllCubelets();
            console.log('üîç Found', allCubelets.length, 'cubelets');
            
            // Check if all cubelets are in their solved positions
            const solvedPositions = [
                [-0.6, 0.6, -0.6], [0.6, 0.6, -0.6], [0.6, -0.6, -0.6], [-0.6, -0.6, -0.6],
                [-0.6, 0.6, 0.6], [0.6, 0.6, 0.6], [0.6, -0.6, 0.6], [-0.6, -0.6, 0.6]
            ];
            
            let solved = true;
            solvedPositions.forEach((pos, index) => {
                const cubelet = allCubelets.find(c => 
                    Math.abs(c.position.x - pos[0]) < 0.1 &&
                    Math.abs(c.position.y - pos[1]) < 0.1 &&
                    Math.abs(c.position.z - pos[2]) < 0.1
                );
                
                if (cubelet) {
                    console.log(`‚úÖ Cubelet ${index} at correct position:`, pos);
                } else {
                    console.log(`‚ùå Cubelet ${index} NOT at correct position:`, pos);
                    solved = false;
                }
            });
            
            if (solved) {
                console.log('üéâ Cube appears to be solved!');
                updateStatus('üéâ Cube is solved!');
            } else {
                console.log('‚ùå Cube is not solved');
                updateStatus('‚ùå Cube is not solved');
            }
            
            return solved;
        };
        
        // Rotate face and update internal state
        function rotateFace(move) {
            const face = move.replace("'", "");
            const reverse = move.includes("'") ? 2 : 1;
            
            console.log(`üîÑ Rotating face: ${move} (${face}, reverse: ${reverse})`);
            
            // Animate the visual rotation
            rotate2x2Face(face, reverse, () => {
                console.log(`‚úÖ Completed visual rotation: ${move}`);
            });
        }
        
        // Update cube state after a move
        function updateCubeState(move) {
            console.log(`üîç Updating internal cube state with: ${move}`);
            
            // Get the current solver instance
            const solver = new CubeSolver();
            solver.updateCubeState(move);
            
            console.log(`‚úÖ Internal cube updated with: ${move}`);
        }
        
        // Apply move sequence with animation and state updates
        function applyMoveSequence(moves) {
            console.log('üé¨ Starting move sequence:', moves);
            
            let i = 0;
            function nextMove() {
                if (i < moves.length) {
                    const move = moves[i];
                    console.log(`üé¨ Executing move ${i + 1}/${moves.length}: ${move}`);
                    
                    // Animate the move
                    rotateFace(move);
                    
                    // Update internal state
                    updateCubeState(move);
                    
                    i++;
                    setTimeout(nextMove, 400); // 400ms delay between moves
                } else {
                    console.log('‚úÖ Move sequence completed!');
                    updateStatus('‚úÖ LBL solve completed!');
                }
            }
            
            nextMove();
        }
        
        // Main LBL solve function
        window.solveWithLBL = function() {
            console.log('üß† Starting LBL solve...');
            
            // Create solver instance
            const solver = new CubeSolver();
            
            // Validate cube state
            if (!solver.validateCubeState()) {
                console.error('‚ùå Invalid cube state detected');
                alert("‚ùå Invalid cube state - cannot solve");
                updateStatus('‚ùå Invalid cube state');
                return;
            }
            
            console.log('‚úÖ Cube state validated');
            updateStatus('üß† Generating LBL solution...');
            
            // Get LBL move sequence
            const moves = solver.getLBLMoveSequence();
            console.log('üîç LBL moves generated:', moves);
            
            if (moves.length === 0) {
                console.log('‚ùå No moves generated');
                updateStatus('‚ùå No solution found');
                return;
            }
            
            updateStatus(`üß† Executing LBL solve (${moves.length} moves)...`);
            
            // Apply the move sequence
            applyMoveSequence(moves);
        }
        
        // Test the new LBL solver
        window.testNewLBL = () => {
            console.log('üß™ Testing new LBL solver...');
            
            // Create solver instance
            const solver = new CubeSolver();
            
            console.log('üîç Internal state:', solver.internalState);
            console.log('üîç Visual state:', solver.visualState);
            
            // Test validation
            const isValid = solver.validateCubeState();
            console.log('üîç State validation:', isValid);
            
            // Test LBL sequence generation
            const moves = solver.getLBLMoveSequence();
            console.log('üîç LBL moves:', moves);
            
            return { solver, isValid, moves };
        };
        
        // Test the comprehensive solver
        window.testComprehensiveSolve = () => {
            console.log('üß™ Testing comprehensive solve...');
            const solver = new CubeSolver();
            const analysis = solver.analyzeCurrentState();
            console.log('üîç Current state analysis:', analysis);
            
            const algorithm = generateDynamicAlgorithm();
            console.log('üîç Generated algorithm:', algorithm);
            
            if (algorithm.length === 0) {
                console.log('‚ùå No algorithm generated!');
                return;
            }
            
            window.currentAlgorithm = algorithm;
            currentStep = 0;
            isSolving = true;
            executeNextStep();
        };
        
        // Quick test function for console
        window.quickTest = () => {
            console.log('üß™ Quick test - analyzing cube state...');
            const solver = new CubeSolver();
            console.log('Cube state:', solver.cubeState);
            const analysis = solver.analyzeCurrentState();
            console.log('Analysis:', analysis);
            const solution = solver.generateSolution();
            console.log('Solution:', solution);
            return { solver, analysis, solution };
        };
        
        // Advanced test function that shows detailed analysis
        window.advancedTest = () => {
            console.log('üß™ === ADVANCED CUBE ANALYSIS ===');
            const solver = new CubeSolver();
            
            console.log('üîç Corner Analysis:');
            solver.cubeState.corners.forEach((corner, index) => {
                if (corner) {
                    console.log(`  Corner ${index} (${corner.name}):`);
                    console.log(`    Colors:`, corner.colors);
                    console.log(`    Expected:`, solver.getExpectedCornerColors(index));
                    console.log(`    Position:`, corner.cubelet.position);
                }
            });
            
            console.log('üîç Face Analysis:');
            Object.entries(solver.cubeState.faces).forEach(([face, colors]) => {
                console.log(`  ${face}:`, colors);
            });
            
            const analysis = solver.analyzeCurrentState();
            console.log('üîç State Analysis:', analysis);
            
            const specificMoves = solver.generateSpecificMoves(analysis);
            console.log('üîç Specific Moves:', specificMoves);
            
            const solution = solver.generateSolution();
            console.log('üîç Final Solution:', solution);
            
            return { solver, analysis, specificMoves, solution };
        };
        
        // Detailed analysis function
        window.detailedAnalysis = () => {
            console.log('üîç === DETAILED CUBE ANALYSIS ===');
            const solver = new CubeSolver();
            const analysis = solver.analyzeCurrentState();
            
            console.log('üîç Cube State:', solver.cubeState);
            console.log('üîç Analysis:', analysis);
            console.log('üîç Face Colors:');
            Object.entries(solver.cubeState.faces).forEach(([face, colors]) => {
                console.log(`  ${face}:`, colors);
            });
            
            console.log('üîç Corner Details:');
            solver.cubeState.corners.forEach((corner, index) => {
                if (corner) {
                    console.log(`  Corner ${index} (${corner.name}):`, corner.colors);
                }
            });
            
            return { solver, analysis };
        };
        
        // Test the solver with a more comprehensive approach
        window.testComprehensiveSolve = () => {
            console.log('üß™ Testing comprehensive solve...');
            const solver = new CubeSolver();
            const analysis = solver.analyzeCurrentState();
            console.log('üîç Current state analysis:', analysis);
            
            const algorithm = generateDynamicAlgorithm();
            console.log('üîç Generated algorithm:', algorithm);
            
            if (algorithm.length === 0) {
                console.log('‚ùå No algorithm generated!');
                return;
            }
            
            window.currentAlgorithm = algorithm;
            currentStep = 0;
            isSolving = true;
            executeNextStep();
        };
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            initSolverScene();
            
            // Add scramble button handler
            const scrambleBtn = document.getElementById('scrambleBtn');
            if (scrambleBtn) {
                scrambleBtn.addEventListener('click', () => {
                    scrambleCube();
                });
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('cube-container');
            if (container && camera && renderer) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
    </script>
</body>
</html> 